// Generated by CoffeeScript 1.8.0

/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
 */
describe('Deft.mixin.Injectable', function() {
  afterEach(function() {
    var _base;
    if (typeof (_base = Deft.Injector.inject).restore === "function") {
      _base.restore();
    }
  });
  specify('should trigger injection before the target class constructor is executed', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier'],
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier: 'identifier'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleClass');
    delete ExampleClass;
  });
  specify('should should merge subclass injections with parent class injections', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass',
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier2'],
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
  });
  specify('should should merge multiple levels of inherited injections', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass',
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier2']
    });
    Ext.define('ExampleSubclass2', {
      extend: 'ExampleSubclass',
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier3', 'identifier4'],
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2',
          identifier3: 'identifier3',
          identifier4: 'identifier4'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass2');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
    delete ExampleSubclass2;
  });
  specify('should should merge multiple levels of inherited injections when only the root class in the class hierarchy has injections', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1', 'identifier2']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass'
    });
    Ext.define('ExampleSubclass2', {
      extend: 'ExampleSubclass',
      constructor: function() {
        this.callParent();
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2'
        });
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
      }
    });
    exampleInstance = Ext.create('ExampleSubclass2');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
    delete ExampleSubclass2;
  });
  specify('should should merge multiple levels of inherited injections when an intermediate class in the class hierarchy has no injections', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass'
    });
    Ext.define('ExampleSubclass2', {
      extend: 'ExampleSubclass',
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier2', 'identifier3'],
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2',
          identifier3: 'identifier3'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass2');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
    delete ExampleSubclass2;
  });
  specify('should should merge multiple levels of inherited injections when only the intermediate class in the class hierarchy has injections', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {});
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass',
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1', 'identifier2']
    });
    Ext.define('ExampleSubclass2', {
      extend: 'ExampleSubclass',
      constructor: function() {
        this.callParent();
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        return expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2'
        });
      }
    });
    exampleInstance = Ext.create('ExampleSubclass2');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
    delete ExampleSubclass2;
  });
  specify('should should merge multiple levels of inherited injections when only the leaf class in the class hierarchy has injections', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {});
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass'
    });
    Ext.define('ExampleSubclass2', {
      extend: 'ExampleSubclass',
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1', 'identifier2'],
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass2');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
    delete ExampleSubclass2;
  });
  specify('should should merge inherited injections when some injections are specified as Strings', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1', 'identifier2']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass',
      mixins: ['Deft.mixin.Injectable'],
      inject: 'identifier3',
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2',
          identifier3: 'identifier3'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
  });
  specify('should should merge inherited injections when some injections are specified as Objects', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass',
      mixins: ['Deft.mixin.Injectable'],
      inject: {
        identifier2: 'identifier2',
        identifier3: 'identifier3'
      },
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'identifier1',
          identifier2: 'identifier2',
          identifier3: 'identifier3'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
  });
  specify('should should allow child injections into a property to override parent injections into that property', function() {
    var exampleInstance, injectStub;
    injectStub = sinon.stub(Deft.Injector, 'inject');
    Ext.define('ExampleClass', {
      mixins: ['Deft.mixin.Injectable'],
      inject: ['identifier1', 'identifier2', 'identifier3']
    });
    Ext.define('ExampleSubclass', {
      extend: 'ExampleClass'
    });
    Ext.define('ExampleSubclass2', {
      extend: 'ExampleSubclass',
      mixins: ['Deft.mixin.Injectable'],
      inject: {
        identifier1: 'overriddenIdentifier1',
        identifier2: 'overriddenIdentifier2',
        identifier4: 'identifier4'
      },
      constructor: function() {
        expect(injectStub).to.be.calledWith(this.inject, this, arguments, false);
        expect(this.inject).to.be.eql({
          identifier1: 'overriddenIdentifier1',
          identifier2: 'overriddenIdentifier2',
          identifier3: 'identifier3',
          identifier4: 'identifier4'
        });
        return this.callParent();
      }
    });
    exampleInstance = Ext.create('ExampleSubclass2');
    expect(injectStub).to.be.calledOnce;
    delete ExampleClass;
    delete ExampleSubclass;
    delete ExampleSubclass2;
  });
});

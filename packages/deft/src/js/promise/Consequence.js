// Generated by CoffeeScript 1.8.0

/*
Copyright (c) 2012-2014 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
 */

/**
* @private
* Consequences are used internally by a Resolver to capture and notify
* callbacks, and propagate their transformed results as fulfillment or
* rejection.
*
* Developers never directly interact with a Consequence.
*
* A Consequence forms a chain between two Resolvers, where the result of
* the first Resolver is transformed by the corresponding callback before
* being applied to the second Resolver.
*
* Each time a Resolver's then() method is called, it creates a new
* Consequence that will be triggered once its originating Resolver has
* been fulfilled or rejected. A Consequence captures a pair of optional
* onFulfilled and onRejected callbacks.
*
* Each Consequence has its own Resolver (which in turn has a Promise)
* that is resolved or rejected when the Consequence is triggered. When a
* Consequence is triggered by its originating Resolver, it calls the
* corresponding callback and propagates the transformed result to its own
* Resolver; resolved with the callback return value or rejected with any
* error thrown by the callback.
 */
Ext.define('Deft.promise.Consequence', {
  alternateClassName: ['Deft.Consequence'],
  requires: ['Deft.util.Function'],

  /**
     * @property {Deft.promise.Promise}
     * Promise of the future value of this Consequence.
   */
  promise: null,

  /**
     * @private
     * @property {Deft.promise.Resolver}
     * Internal Resolver for this Consequence.
   */
  resolver: null,

  /**
     * @private
     * @property {Function}
     Callback to execute when this Consequence is triggered with a fulfillment value.
   */
  onFulfilled: null,

  /**
     * @private
     * @property {Function}
     Callback to execute when this Consequence is triggered with a rejection reason.
   */
  onRejected: null,

  /**
     * @private
     * @property {Function}
     Callback to execute when this Consequence is updated with a progress value.
   */
  onProgress: null,

  /**
  	* @param {Function} onFulfilled Callback to execute to transform a fulfillment value.
  	* @param {Function} onRejected Callback to execute to transform a rejection reason.
   */
  constructor: function(onFulfilled, onRejected, onProgress) {
    this.onFulfilled = onFulfilled;
    this.onRejected = onRejected;
    this.onProgress = onProgress;
    this.resolver = Ext.create('Deft.promise.Resolver');
    this.promise = this.resolver.promise;
    return this;
  },

  /**
     * Trigger this Consequence with the specified action and value.
  	*
  	* @param {String} action Completion action (i.e. fulfill or reject).
  	* @param {Mixed} value Fulfillment value or rejection reason.
   */
  trigger: function(action, value) {
    switch (action) {
      case 'fulfill':
        this.propagate(value, this.onFulfilled, this.resolver, this.resolver.resolve);
        break;
      case 'reject':
        this.propagate(value, this.onRejected, this.resolver, this.resolver.reject);
    }
  },

  /**
  	* Update this Consequence with the specified progress value.
  	*
  	* @param {Mixed} value Progress value.
   */
  update: function(progress) {
    if (Deft.isFunction(this.onProgress)) {
      progress = this.onProgress(progress);
    }
    this.resolver.update(progress);
  },

  /**
  	* @private
  	* Transform and propagate the specified value using the
     * optional callback and propagate the transformed result.
  	*
  	* @param {Mixed} value Value to transform and/or propagate.
  	* @param {Function} callback (Optional) callback to use to transform the value.
  	* @param {Function} resolver Resolver to use to propagate the value, if no callback was specified.
  	* @param {Function} resolverMethod Resolver method to call to propagate the value, if no callback was specified.
   */
  propagate: function(value, callback, resolver, resolverMethod) {
    if (Deft.isFunction(callback)) {
      this.schedule(function() {
        var error;
        try {
          resolver.resolve(callback(value));
        } catch (_error) {
          error = _error;
          resolver.reject(error);
        }
      });
    } else {
      resolverMethod.call(this.resolver, value);
    }
  },

  /**
  	* @private
  	* @method
  	* Schedules the specified callback function to be executed on
     * the next turn of the event loop.
  	*
  	* @param {Function} callback Callback function.
     * @param {Mixed[]} parameters Optional callback parameters.
  	* @param {Object} scope Optional scope for the callback.
   */
  schedule: Ext.emptyFn
}, function() {
  var CallbackQueue, callbackQueue, nextTick;
  nextTick = typeof setImmediate !== "undefined" && setImmediate !== null ? setImmediate : function(task) {
    return setTimeout(task, 0);
  };
  CallbackQueue = (function() {
    function CallbackQueue() {
      var execute, queuedCallbackCount, queuedCallbacks;
      queuedCallbacks = new Array(1e4);
      queuedCallbackCount = 0;
      execute = function() {
        var index;
        index = 0;
        while (index < queuedCallbackCount) {
          queuedCallbacks[index]();
          queuedCallbacks[index] = null;
          index++;
        }
        queuedCallbackCount = 0;
      };
      this.schedule = function(callback) {
        queuedCallbacks[queuedCallbackCount++] = callback;
        if (queuedCallbackCount === 1) {
          nextTick(execute);
        }
      };
    }

    return CallbackQueue;

  })();
  callbackQueue = new CallbackQueue();
  this.prototype.schedule = function(callback, parameters, scope) {
    callbackQueue.schedule(callback, parameters, scope);
  };
});

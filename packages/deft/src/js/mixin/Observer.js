// Generated by CoffeeScript 1.8.0

/*
Copyright (c) 2012-2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
 */

/**
* A mixin that marks a class as an observer of events from Observable objects.
* Classes using the mixin should call the mixed-in method 'createObservers()' to
* trigger creation of the event listeners using the 'observe:' configuration.
* The Deft JS ViewController uses this mixin, adding the Observers at construction
* and removing them on ViewController destruction.
*
* **IMPORTANT NOTE:** If you choose to use this mixin in your own classes, and you intend
* to destroy the instance, you **MUST** call the mixed-in method 'removeObservers()' at
* destruction time! Failure to do this will result in memory leaks, since the event
* listeners will not be cleaned up. There is no standard way for this mixin to be notified
* of pending instance destruction, so the developer must ensure that this is done.
 */
Ext.define('Deft.mixin.Observer', {
  requires: ['Deft.log.Logger', 'Deft.util.DeftMixinUtils'],

  /**
  	@private
   */
  onClassMixedIn: function(target) {
    target.override({
      constructor: Deft.mixin.Observer.createMixinInterceptor()
    });
    target.onExtended(function(clazz, config) {
      clazz.override({
        constructor: Deft.mixin.Observer.createMixinInterceptor()
      });
      return true;
    });
  },

  /**
  	* @protected
   */
  createObservers: function() {
    var events, target, _ref;
    this.removeObservers();
    this.registeredObservers = {};
    _ref = this.observe;
    for (target in _ref) {
      events = _ref[target];
      this.addObserver(target, events);
    }
  },

  /**
  	* @protected
   */
  addObserver: function(target, events) {
    var observer;
    observer = Ext.create('Deft.mvc.Observer', {
      host: this,
      target: target,
      events: events
    });
    this.registeredObservers[target] = observer;
  },

  /**
  	* @protected
   */
  removeObservers: function() {
    var observer, target, _ref;
    _ref = this.registeredObservers;
    for (target in _ref) {
      observer = _ref[target];
      observer.destroy();
      delete this.registeredObservers[target];
    }
  },
  statics: {
    MIXIN_COMPLETED_KEY: "$observing",
    PROPERTY_NAME: "observe",

    /**
    		* @private
     */
    createMixinInterceptor: function() {
      return function(config) {
        var mixinCompletedKey, propertyName;
        if (config == null) {
          config = {};
        }
        mixinCompletedKey = Deft.mixin.Observer.MIXIN_COMPLETED_KEY;
        propertyName = Deft.mixin.Observer.PROPERTY_NAME;
        if (this[propertyName] == null) {
          this[propertyName] = {};
        }
        if (!this[mixinCompletedKey] && Ext.Object.getSize(this[propertyName]) > 0) {
          Deft.util.DeftMixinUtils.mergeSuperclassProperty(this, propertyName, Deft.mixin.Observer.propertyMergeHandler);
          Deft.mixin.Observer.afterMixinProcessed(this);
          this[Deft.util.DeftMixinUtils.parentConstructorForVersion()](arguments);
          return this;
        }
        return this[Deft.util.DeftMixinUtils.parentConstructorForVersion()](arguments);
      };
    },

    /**
    		* @private
    		* Called by DeftMixinUtils.mergeSuperclassProperty(). Allows each mixin to define its own
    		* customized subclass/superclass merge logic.
    		*
    		* Merges child and parent observers into a single object. This differs from a normal object merge because
    		* a given observer target and event can potentially have multiple handlers declared in different parent or
    		* child classes. It transforms an event handler value into an array of values, and merges the arrays of handlers
    		* from child to parent. This maintains the handlers even if both parent and child classes have handlers for the
    		* same target and event.
     */
    propertyMergeHandler: function(originalParentObserve, originalChildObserve) {
      var childEvent, childEvents, childHandler, childHandlerArray, childObserve, childTarget, eventOptionNames, parentEvent, parentEvents, parentHandler, parentHandlerArray, parentObserve, parentTarget, _ref, _ref1;
      if (!Ext.isObject(originalParentObserve)) {
        parentObserve = {};
      } else {
        parentObserve = Ext.clone(originalParentObserve);
      }
      if (!Ext.isObject(originalChildObserve)) {
        childObserve = {};
      } else {
        childObserve = Ext.clone(originalChildObserve);
      }
      eventOptionNames = ["buffer", "single", "delay", "element", "target", "destroyable"];
      Deft.mixin.Observer.convertConfigArray(parentObserve, eventOptionNames);
      Deft.mixin.Observer.convertConfigArray(childObserve, eventOptionNames);
      for (childTarget in childObserve) {
        childEvents = childObserve[childTarget];
        for (childEvent in childEvents) {
          childHandler = childEvents[childEvent];
          if (Ext.isString(childHandler)) {
            childObserve[childTarget][childEvent] = childHandler.replace(' ', '').split(',');
          }
          if (!(parentObserve != null ? parentObserve[childTarget] : void 0)) {
            parentObserve[childTarget] = {};
          }
          if (!(parentObserve != null ? (_ref = parentObserve[childTarget]) != null ? _ref[childEvent] : void 0 : void 0)) {
            parentObserve[childTarget][childEvent] = childObserve[childTarget][childEvent];
            delete childObserve[childTarget][childEvent];
          }
        }
      }
      for (parentTarget in parentObserve) {
        parentEvents = parentObserve[parentTarget];
        for (parentEvent in parentEvents) {
          parentHandler = parentEvents[parentEvent];
          if (Ext.isString(parentHandler)) {
            parentObserve[parentTarget][parentEvent] = parentHandler.split(',');
          }
          if (childObserve != null ? (_ref1 = childObserve[parentTarget]) != null ? _ref1[parentEvent] : void 0 : void 0) {
            childHandlerArray = childObserve[parentTarget][parentEvent];
            parentHandlerArray = parentObserve[parentTarget][parentEvent];
            parentObserve[parentTarget][parentEvent] = Ext.Array.unique(Ext.Array.insert(parentHandlerArray, 0, childHandlerArray));
          }
        }
      }
      return parentObserve;
    },

    /**
    		* @private
    		* Converts an observe configuration that use an array of event configuration objects into object keys for
    		* event name, containing an array of configuration objects.
     */
    convertConfigArray: function(observeConfig, eventOptionNames) {
      var handlerConfig, newObserveEvents, observeEvents, observeTarget, thisEventOptionName, thisObserveEvent, _i, _j, _len, _len1, _results;
      _results = [];
      for (observeTarget in observeConfig) {
        observeEvents = observeConfig[observeTarget];
        if (Ext.isArray(observeEvents)) {
          newObserveEvents = {};
          for (_i = 0, _len = observeEvents.length; _i < _len; _i++) {
            thisObserveEvent = observeEvents[_i];
            if (Ext.Object.getSize(thisObserveEvent) === 1) {
              Ext.apply(newObserveEvents, thisObserveEvent);
            } else {
              handlerConfig = {};
              if ((thisObserveEvent != null ? thisObserveEvent.fn : void 0) != null) {
                handlerConfig.fn = thisObserveEvent.fn;
              }
              if ((thisObserveEvent != null ? thisObserveEvent.scope : void 0) != null) {
                handlerConfig.scope = thisObserveEvent.scope;
              }
              for (_j = 0, _len1 = eventOptionNames.length; _j < _len1; _j++) {
                thisEventOptionName = eventOptionNames[_j];
                if ((thisObserveEvent != null ? thisObserveEvent[thisEventOptionName] : void 0) != null) {
                  handlerConfig[thisEventOptionName] = thisObserveEvent[thisEventOptionName];
                }
              }
              newObserveEvents[thisObserveEvent.event] = [handlerConfig];
            }
          }
          _results.push(observeConfig[observeTarget] = newObserveEvents);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },

    /**
    		@private
     */
    afterMixinProcessed: function(target) {
      target[Deft.mixin.Observer.MIXIN_COMPLETED_KEY] = true;
    }
  }
});
